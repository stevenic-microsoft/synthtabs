<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SynthOS</title>
    <script src="/api/theme-info.js"></script>
    <link rel="stylesheet" href="/api/theme.css">
    <style>
        /* Game Styles */
        #gameCanvas {
            display: block;
        }

        .game-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
        }

        .score-display,
        .lives-display,
        .level-display {
            font-family: 'Orbitron', 'Segoe UI', sans-serif;
            font-size: 18px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
            letter-spacing: 2px;
        }

        .game-over-screen,
        .start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 20;
        }

        .game-over-screen h1,
        .start-screen h1 {
            font-family: 'Orbitron', 'Segoe UI', sans-serif;
            font-size: 48px;
            color: #ff00ff;
            text-shadow: 0 0 20px #ff00ff, 0 0 40px #ff00ff, 0 0 60px #ff00ff;
            margin-bottom: 20px;
            letter-spacing: 5px;
        }

        .game-over-screen p,
        .start-screen p {
            font-size: 18px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            margin-bottom: 30px;
        }

        .start-btn,
        .restart-btn {
            padding: 15px 40px;
            font-size: 18px;
            font-family: 'Orbitron', 'Segoe UI', sans-serif;
            background: transparent;
            border: 2px solid #00ffff;
            color: #00ffff;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3), inset 0 0 20px rgba(0, 255, 255, 0.1);
        }

        .start-btn:hover,
        .restart-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5), inset 0 0 30px rgba(0, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .controls-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            color: rgba(0, 255, 255, 0.6);
            text-align: center;
            letter-spacing: 1px;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&amp;display=swap" rel="stylesheet">
</head>

<body>
    <div class="chat-panel">
        <div class="chat-header">SynthOS</div>
        <div class="chat-messages" id="chatMessages">
            <div class="chat-message">
                <p><strong>SynthOS:</strong> What can I create for you?</p>
            </div>
            <div class="chat-message">
                <p><strong>You:</strong> create super cool version of astroids...</p>
            </div>
            <div class="chat-message">
                <p><strong>SynthOS:</strong> ðŸš€ Launching NEON ASTEROIDS! A synthwave-styled space shooter with glowing
                    neon graphics, particle explosions, screen shake effects, and progressive difficulty. Use WASD or
                    Arrow keys to move, SPACE to shoot. Destroy asteroids, survive, and chase that high score!</p>
            </div>
            <div class="chat-message">
                <p><strong>You:</strong> great game but a couple of things missing... the rocks should progressively
                    speed up as the level increases. dropping power ups that are extra lives should be rare. it's also
                    missing the saucers that fly across the screen and shoot at you starting on level 2</p>
            </div>
            <div class="chat-message">
                <p><strong>SynthOS:</strong> ðŸ›¸ Updated! Added: 1) Asteroids now speed up with each level (+15% per
                    level), 2) Extra life power-ups are now rare (5% chance vs 15% for others), 3) Enemy UFO saucers
                    appear starting Level 2 - they fly across the screen, track you, and shoot back! Small saucers are
                    faster and more accurate. Watch out for those glowing red menaces! ðŸ‘¾</p>
            </div>
        </div>
        <div class="link-group">
            <a href="#" id="saveLink">Save</a>
            <a href="/pages" id="pagesLink">Pages</a>
            <a href="#" id="resetLink">Reset</a>
        </div>
        <form action="/" method="POST" id="chatForm">
            <input type="text" class="chat-input" id="chatInput" name="message" placeholder="Type a message...">
            <button type="submit" class="chat-submit">Send</button>
        </form>
    </div>
    <div class="viewer-panel" id="viewerPanel">
        <canvas id="gameCanvas"></canvas>
        <div class="game-ui">
            <div class="score-display">SCORE: <span id="score">0</span></div>
            <div class="level-display">LEVEL: <span id="level">1</span></div>
            <div class="lives-display">LIVES: <span id="lives">3</span></div>
        </div>
        <div class="start-screen" id="startScreen">
            <h1>NEON ASTEROIDS</h1>
            <p>Navigate the cosmic void. Destroy all asteroids. Beware the saucers!</p>
            <button class="start-btn" id="startBtn">START MISSION</button>
        </div>
        <div class="game-over-screen" id="gameOverScreen" style="display: none;">
            <h1>GAME OVER</h1>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button class="restart-btn" id="restartBtn">TRY AGAIN</button>
        </div>
        <div class="controls-info">WASD / ARROWS to move â€¢ SPACE to fire â€¢ P to pause</div>
        <div id="loadingOverlay" class="loading-overlay">
            <div class="spinner"></div>
        </div>
    </div>
    <div id="thoughts" style="display: none;">Updated the Asteroids game with three key improvements: 1) Asteroid speed
        now scales with level - base speed multiplied by (1 + level * 0.15), making higher levels more challenging. 2)
        Extra life power-ups are now rare at 5% drop chance, while other power-ups remain at 15%. 3) Added UFO saucers
        that spawn starting at level 2. Saucers come in two sizes - large (slower, less accurate) and small (faster,
        more accurate). They fly horizontally across the screen, periodically shoot at the player with aimed bullets,
        and are worth bonus points. Saucers have a distinct red/orange glow and make the game feel more like classic
        Asteroids.</div>
    <script id="asteroids-game">
        // NEON ASTEROIDS GAME
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const viewerPanel = document.getElementById('viewerPanel');

        function resizeCanvas() {
            canvas.width = viewerPanel.clientWidth;
            canvas.height = viewerPanel.clientHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game State
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let lives = 3;
        let level = 1;
        let screenShake = 0;

        // Ship
        const ship = {
            x: 0, y: 0,
            vx: 0, vy: 0,
            angle: -Math.PI / 2,
            radius: 15,
            thrust: 0,
            rotationSpeed: 0,
            invincible: 0,
            shield: 0,
            rapidFire: 0,
            multiShot: 0
        };

        // Arrays
        let bullets = [];
        let asteroids = [];
        let particles = [];
        let powerUps = [];
        let stars = [];
        let saucers = [];
        let saucerBullets = [];

        // Saucer spawn timer
        let saucerSpawnTimer = 0;

        // Input
        const keys = {};

        // Initialize stars
        function initStars() {
            stars = [];
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    speed: Math.random() * 0.5 + 0.1,
                    brightness: Math.random()
                });
            }
        }

        // Initialize game
        function initGame() {
            ship.x = canvas.width / 2;
            ship.y = canvas.height / 2;
            ship.vx = 0;
            ship.vy = 0;
            ship.angle = -Math.PI / 2;
            ship.invincible = 180;
            ship.shield = 0;
            ship.rapidFire = 0;
            ship.multiShot = 0;
            bullets = [];
            asteroids = [];
            particles = [];
            powerUps = [];
            saucers = [];
            saucerBullets = [];
            saucerSpawnTimer = 0;
            score = 0;
            lives = 3;
            level = 1;
            initStars();
            spawnAsteroids(4);
            updateUI();
        }

        // Get speed multiplier based on level
        function getLevelSpeedMultiplier() {
            return 1 + (level - 1) * 0.15;
        }

        // Spawn asteroids
        function spawnAsteroids(count) {
            for (let i = 0; i < count; i++) {
                let x, y;
                do {
                    x = Math.random() * canvas.width;
                    y = Math.random() * canvas.height;
                } while (distance(x, y, ship.x, ship.y) < 150);

                asteroids.push(createAsteroid(x, y, 3));
            }
        }

        function createAsteroid(x, y, size) {
            const baseSpeed = (4 - size) * 0.5 + Math.random() * 1.5;
            const speed = baseSpeed * getLevelSpeedMultiplier();
            const angle = Math.random() * Math.PI * 2;
            const radii = [];
            const points = 8 + Math.floor(Math.random() * 5);
            const baseRadius = size * 15 + 10;

            for (let i = 0; i < points; i++) {
                radii.push(baseRadius * (0.7 + Math.random() * 0.6));
            }

            return {
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size,
                radii,
                points,
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 0.03,
                color: size === 3 ? '#ff00ff' : size === 2 ? '#ffff00' : '#00ffff'
            };
        }

        // Create saucer
        function createSaucer() {
            const isSmall = Math.random() > 0.5;
            const fromLeft = Math.random() > 0.5;
            const y = Math.random() * (canvas.height - 100) + 50;

            return {
                x: fromLeft ? -30 : canvas.width + 30,
                y: y,
                vx: (fromLeft ? 1 : -1) * (isSmall ? 3 : 2) * getLevelSpeedMultiplier(),
                vy: 0,
                isSmall: isSmall,
                radius: isSmall ? 15 : 25,
                shootTimer: 60 + Math.random() * 60,
                directionChangeTimer: 60 + Math.random() * 120,
                points: isSmall ? 1000 : 500
            };
        }

        // Distance helper
        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        // Wrap position
        function wrap(obj) {
            if (obj.x < -50) obj.x = canvas.width + 50;
            if (obj.x > canvas.width + 50) obj.x = -50;
            if (obj.y < -50) obj.y = canvas.height + 50;
            if (obj.y > canvas.height + 50) obj.y = -50;
        }

        // Create particles
        function createExplosion(x, y, color, count = 20) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 60 + Math.random() * 30,
                    maxLife: 90,
                    color,
                    size: Math.random() * 3 + 1
                });
            }
            screenShake = 10;
        }

        // Shoot
        let shootCooldown = 0;
        function shoot() {
            if (shootCooldown > 0) return;

            const cooldown = ship.rapidFire > 0 ? 5 : 15;
            shootCooldown = cooldown;

            const angles = ship.multiShot > 0 ? [-0.2, 0, 0.2] : [0];

            angles.forEach(offset => {
                const angle = ship.angle + offset;
                bullets.push({
                    x: ship.x + Math.cos(angle) * 20,
                    y: ship.y + Math.sin(angle) * 20,
                    vx: Math.cos(angle) * 10 + ship.vx * 0.5,
                    vy: Math.sin(angle) * 10 + ship.vy * 0.5,
                    life: 60
                });
            });
        }

        // Saucer shoot
        function saucerShoot(saucer) {
            let angle = Math.atan2(ship.y - saucer.y, ship.x - saucer.x);

            // Add inaccuracy based on saucer size
            if (!saucer.isSmall) {
                angle += (Math.random() - 0.5) * 0.5;
            } else {
                angle += (Math.random() - 0.5) * 0.2;
            }

            const speed = 6;
            saucerBullets.push({
                x: saucer.x,
                y: saucer.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 90
            });
        }

        // Spawn power-up
        function spawnPowerUp(x, y) {
            if (Math.random() > 0.15) return;

            // Extra lives are rare (5% of power-ups)
            let type;
            const rand = Math.random();
            if (rand < 0.05) {
                type = 'life';
            } else if (rand < 0.38) {
                type = 'shield';
            } else if (rand < 0.71) {
                type = 'rapid';
            } else {
                type = 'multi';
            }

            powerUps.push({
                x, y,
                type,
                life: 600,
                pulse: 0
            });
        }

        // Update UI
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('lives').textContent = lives;
        }

        // Game loop
        function update() {
            if (!gameRunning || gamePaused) return;

            // Ship controls
            if (keys['ArrowLeft'] || keys['KeyA']) ship.angle -= 0.08;
            if (keys['ArrowRight'] || keys['KeyD']) ship.angle += 0.08;

            if (keys['ArrowUp'] || keys['KeyW']) {
                ship.vx += Math.cos(ship.angle) * 0.15;
                ship.vy += Math.sin(ship.angle) * 0.15;
                ship.thrust = 1;
            } else {
                ship.thrust *= 0.95;
            }

            if (keys['Space']) shoot();

            // Ship physics
            ship.vx *= 0.99;
            ship.vy *= 0.99;
            const maxSpeed = 8;
            const speed = Math.sqrt(ship.vx ** 2 + ship.vy ** 2);
            if (speed > maxSpeed) {
                ship.vx = (ship.vx / speed) * maxSpeed;
                ship.vy = (ship.vy / speed) * maxSpeed;
            }
            ship.x += ship.vx;
            ship.y += ship.vy;
            wrap(ship);

            // Timers
            if (ship.invincible > 0) ship.invincible--;
            if (ship.shield > 0) ship.shield--;
            if (ship.rapidFire > 0) ship.rapidFire--;
            if (ship.multiShot > 0) ship.multiShot--;
            if (shootCooldown > 0) shootCooldown--;

            // Saucer spawning (level 2+)
            if (level >= 2) {
                saucerSpawnTimer++;
                const spawnInterval = Math.max(300, 600 - level * 30);
                if (saucerSpawnTimer >= spawnInterval && saucers.length < 2) {
                    saucers.push(createSaucer());
                    saucerSpawnTimer = 0;
                }
            }

            // Update saucers
            saucers = saucers.filter(s => {
                s.x += s.vx;
                s.y += s.vy;

                // Direction change
                s.directionChangeTimer--;
                if (s.directionChangeTimer <= 0) {
                    s.vy = (Math.random() - 0.5) * 2;
                    s.directionChangeTimer = 60 + Math.random() * 120;
                }

                // Keep in vertical bounds
                if (s.y < 50) s.vy = Math.abs(s.vy);
                if (s.y > canvas.height - 50) s.vy = -Math.abs(s.vy);

                // Shooting
                s.shootTimer--;
                if (s.shootTimer <= 0) {
                    saucerShoot(s);
                    s.shootTimer = s.isSmall ? 40 + Math.random() * 40 : 60 + Math.random() * 60;
                }

                // Remove if off screen
                return s.x > -50 && s.x < canvas.width + 50;
            });

            // Update saucer bullets
            saucerBullets = saucerBullets.filter(b => {
                b.x += b.vx;
                b.y += b.vy;
                b.life--;
                return b.life > 0 && b.x > -10 && b.x < canvas.width + 10 && b.y > -10 && b.y < canvas.height + 10;
            });

            // Update bullets
            bullets = bullets.filter(b => {
                b.x += b.vx;
                b.y += b.vy;
                b.life--;
                wrap(b);
                return b.life > 0;
            });

            // Update asteroids
            asteroids.forEach(a => {
                a.x += a.vx;
                a.y += a.vy;
                a.rotation += a.rotationSpeed;
                wrap(a);
            });

            // Update particles
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.98;
                p.vy *= 0.98;
                p.life--;
                return p.life > 0;
            });

            // Update power-ups
            powerUps = powerUps.filter(p => {
                p.life--;
                p.pulse += 0.1;
                return p.life > 0;
            });

            // Update stars
            stars.forEach(s => {
                s.y += s.speed;
                if (s.y > canvas.height) {
                    s.y = 0;
                    s.x = Math.random() * canvas.width;
                }
                s.brightness = 0.3 + Math.sin(Date.now() * 0.003 + s.x) * 0.3;
            });

            // Collision: bullets vs asteroids
            bullets.forEach((b, bi) => {
                asteroids.forEach((a, ai) => {
                    const avgRadius = a.radii.reduce((sum, r) => sum + r, 0) / a.radii.length;
                    if (distance(b.x, b.y, a.x, a.y) < avgRadius) {
                        bullets.splice(bi, 1);
                        createExplosion(a.x, a.y, a.color, 15);

                        // Split asteroid
                        if (a.size > 1) {
                            for (let i = 0; i < 2; i++) {
                                asteroids.push(createAsteroid(a.x, a.y, a.size - 1));
                            }
                        }

                        spawnPowerUp(a.x, a.y);
                        asteroids.splice(ai, 1);
                        score += (4 - a.size) * 100;
                        updateUI();
                    }
                });
            });

            // Collision: bullets vs saucers
            bullets.forEach((b, bi) => {
                saucers.forEach((s, si) => {
                    if (distance(b.x, b.y, s.x, s.y) < s.radius) {
                        bullets.splice(bi, 1);
                        createExplosion(s.x, s.y, '#ff6600', 25);
                        score += s.points;
                        saucers.splice(si, 1);
                        updateUI();
                    }
                });
            });

            // Collision: ship vs asteroids
            if (ship.invincible <= 0 && ship.shield <= 0) {
                asteroids.forEach((a, ai) => {
                    const avgRadius = a.radii.reduce((sum, r) => sum + r, 0) / a.radii.length;
                    if (distance(ship.x, ship.y, a.x, a.y) < avgRadius + ship.radius) {
                        createExplosion(ship.x, ship.y, '#00ffff', 30);
                        lives--;
                        updateUI();

                        if (lives <= 0) {
                            gameOver();
                        } else {
                            ship.x = canvas.width / 2;
                            ship.y = canvas.height / 2;
                            ship.vx = 0;
                            ship.vy = 0;
                            ship.invincible = 180;
                        }
                    }
                });
            }

            // Collision: ship vs saucers
            if (ship.invincible <= 0 && ship.shield <= 0) {
                saucers.forEach((s, si) => {
                    if (distance(ship.x, ship.y, s.x, s.y) < s.radius + ship.radius) {
                        createExplosion(ship.x, ship.y, '#00ffff', 30);
                        createExplosion(s.x, s.y, '#ff6600', 25);
                        saucers.splice(si, 1);
                        lives--;
                        updateUI();

                        if (lives <= 0) {
                            gameOver();
                        } else {
                            ship.x = canvas.width / 2;
                            ship.y = canvas.height / 2;
                            ship.vx = 0;
                            ship.vy = 0;
                            ship.invincible = 180;
                        }
                    }
                });
            }

            // Collision: ship vs saucer bullets
            if (ship.invincible <= 0 && ship.shield <= 0) {
                saucerBullets.forEach((b, bi) => {
                    if (distance(ship.x, ship.y, b.x, b.y) < ship.radius + 5) {
                        createExplosion(ship.x, ship.y, '#00ffff', 30);
                        saucerBullets.splice(bi, 1);
                        lives--;
                        updateUI();

                        if (lives <= 0) {
                            gameOver();
                        } else {
                            ship.x = canvas.width / 2;
                            ship.y = canvas.height / 2;
                            ship.vx = 0;
                            ship.vy = 0;
                            ship.invincible = 180;
                        }
                    }
                });
            }

            // Collision: ship vs power-ups
            powerUps.forEach((p, pi) => {
                if (distance(ship.x, ship.y, p.x, p.y) < 30) {
                    powerUps.splice(pi, 1);
                    createExplosion(p.x, p.y, '#00ff00', 10);

                    switch (p.type) {
                        case 'shield': ship.shield = 600; break;
                        case 'rapid': ship.rapidFire = 600; break;
                        case 'multi': ship.multiShot = 600; break;
                        case 'life': lives = Math.min(lives + 1, 5); updateUI(); break;
                    }
                }
            });

            // Level complete
            if (asteroids.length === 0) {
                level++;
                updateUI();
                spawnAsteroids(3 + level);
                saucerSpawnTimer = 0;
            }

            // Screen shake decay
            if (screenShake > 0) screenShake *= 0.9;
        }

        // Draw
        function draw() {
            ctx.save();

            // Screen shake
            if (screenShake > 0.5) {
                ctx.translate(
                    (Math.random() - 0.5) * screenShake,
                    (Math.random() - 0.5) * screenShake
                );
            }

            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
            stars.forEach(s => {
                ctx.fillStyle = `rgba(255, 255, 255, ${s.brightness})`;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw particles
            particles.forEach(p => {
                const alpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });

            // Draw power-ups
            powerUps.forEach(p => {
                const pulse = Math.sin(p.pulse) * 5;
                ctx.strokeStyle = p.type === 'shield' ? '#00ffff' :
                    p.type === 'rapid' ? '#ff0000' :
                        p.type === 'multi' ? '#ffff00' : '#00ff00';
                ctx.lineWidth = 2;
                ctx.shadowColor = ctx.strokeStyle;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 15 + pulse, 0, Math.PI * 2);
                ctx.stroke();

                // Icon
                ctx.fillStyle = ctx.strokeStyle;
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const icon = p.type === 'shield' ? 'S' :
                    p.type === 'rapid' ? 'R' :
                        p.type === 'multi' ? 'M' : '+';
                ctx.fillText(icon, p.x, p.y);
                ctx.shadowBlur = 0;
            });

            // Draw asteroids
            asteroids.forEach(a => {
                ctx.save();
                ctx.translate(a.x, a.y);
                ctx.rotate(a.rotation);

                ctx.strokeStyle = a.color;
                ctx.lineWidth = 2;
                ctx.shadowColor = a.color;
                ctx.shadowBlur = 20;

                ctx.beginPath();
                for (let i = 0; i < a.points; i++) {
                    const angle = (i / a.points) * Math.PI * 2;
                    const r = a.radii[i];
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
            });

            // Draw saucers
            saucers.forEach(s => {
                ctx.save();
                ctx.translate(s.x, s.y);

                ctx.strokeStyle = '#ff6600';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 20;

                const r = s.radius;

                // Draw UFO shape
                ctx.beginPath();
                // Top dome
                ctx.ellipse(0, -r * 0.2, r * 0.4, r * 0.3, 0, Math.PI, 0);
                ctx.stroke();

                // Main body
                ctx.beginPath();
                ctx.ellipse(0, 0, r, r * 0.35, 0, 0, Math.PI * 2);
                ctx.stroke();

                // Bottom
                ctx.beginPath();
                ctx.ellipse(0, r * 0.15, r * 0.5, r * 0.2, 0, 0, Math.PI);
                ctx.stroke();

                // Lights
                ctx.fillStyle = '#ff6600';
                for (let i = 0; i < 3; i++) {
                    const lx = (i - 1) * r * 0.5;
                    ctx.beginPath();
                    ctx.arc(lx, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            });

            // Draw saucer bullets
            saucerBullets.forEach(b => {
                ctx.fillStyle = '#ff6600';
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw bullets
            bullets.forEach(b => {
                ctx.fillStyle = '#00ffff';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
                ctx.fill();

                // Trail
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(b.x, b.y);
                ctx.lineTo(b.x - b.vx * 2, b.y - b.vy * 2);
                ctx.stroke();
            });

            // Draw ship
            if (gameRunning && (ship.invincible <= 0 || Math.floor(ship.invincible / 5) % 2 === 0)) {
                ctx.save();
                ctx.translate(ship.x, ship.y);
                ctx.rotate(ship.angle);

                // Shield effect
                if (ship.shield > 0) {
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(0, 0, 25, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Ship body
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;

                ctx.beginPath();
                ctx.moveTo(20, 0);
                ctx.lineTo(-15, -12);
                ctx.lineTo(-8, 0);
                ctx.lineTo(-15, 12);
                ctx.closePath();
                ctx.stroke();

                // Thrust
                if (ship.thrust > 0.1) {
                    ctx.strokeStyle = '#ff6600';
                    ctx.shadowColor = '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(-8, -5);
                    ctx.lineTo(-20 - Math.random() * 10 * ship.thrust, 0);
                    ctx.lineTo(-8, 5);
                    ctx.stroke();
                }

                ctx.restore();
            }

            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOverScreen').style.display = 'block';
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (e.code === 'KeyP' && gameRunning) {
                gamePaused = !gamePaused;
            }
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', e => {
            keys[e.code] = false;
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            document.getElementById('startScreen').style.display = 'none';
            initGame();
            gameRunning = true;
        });

        document.getElementById('restartBtn').addEventListener('click', () => {
            document.getElementById('gameOverScreen').style.display = 'none';
            initGame();
            gameRunning = true;
        });

        // Start
        initStars();
        gameLoop();
    </script>


</body></html>